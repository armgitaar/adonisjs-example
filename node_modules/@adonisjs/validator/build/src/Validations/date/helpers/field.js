"use strict";
/*
 * @adonisjs/validator
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = exports.compile = void 0;
const luxon_1 = require("luxon");
const helpers_1 = require("../../../Validator/helpers");
/**
 * Returns a luxon date time instance based upon the unit, duration and operator
 */
function compareDateTime(lhs, rhs, operator) {
    switch (operator) {
        case '>':
            return lhs > rhs;
        case '<':
            return lhs < rhs;
        case '>=':
            return lhs >= rhs;
        case '<=':
            return lhs <= rhs;
    }
}
/**
 * Compiles a date field comparison rule
 */
function compile(ruleName, operator, [field]) {
    if (!field) {
        throw new Error(`${ruleName}: expects a comparison "field"`);
    }
    return {
        compiledOptions: {
            operator,
            field,
        },
    };
}
exports.compile = compile;
/**
 * Validates date field comparison rule
 */
function validate(ruleName, errorMessage, value, { field, operator }, { root, tip, errorReporter, pointer, arrayExpressionPointer }) {
    /**
     * Skip when value is not a date time instance. One must use date schema
     * type
     */
    if (value instanceof luxon_1.DateTime === false) {
        return;
    }
    const comparisonValue = helpers_1.getFieldValue(field, root, tip);
    /**
     * Skip when comparison value is not a date time instance. One must use date schema
     * type and put this field above the current field.
     */
    if (comparisonValue instanceof luxon_1.DateTime === false) {
        return;
    }
    if (!compareDateTime(value, comparisonValue, operator)) {
        errorReporter.report(pointer, ruleName, errorMessage, arrayExpressionPointer, {
            otherField: field,
        });
    }
}
exports.validate = validate;

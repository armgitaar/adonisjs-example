"use strict";
/*
* @adonisjs/sink
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
const logger_1 = require("../../logger");
const sink = __importStar(require("../../../index"));
const TemplatesManager_1 = require("../TemplatesManager");
/**
 * Exposes the API to execute the instructions of a package, defined inside
 * the `package.json` file.
 */
class Instructions {
    constructor(packageName, projectRoot, application, verbose = false) {
        this.packageName = packageName;
        this.projectRoot = projectRoot;
        this.application = application;
        this.verbose = verbose;
        /**
         * Path to the package package.json file
         */
        this.packagePath = this.getPackagePath();
        this.markdownDisplay = undefined;
    }
    /**
     * Returns the absolute path to the package
     */
    getPackagePath() {
        try {
            return utils_1.resolveFrom(this.projectRoot, `${this.packageName}/package.json`);
        }
        catch (error) {
            if (['MODULE_NOT_FOUND', 'ENOENT'].includes(error.code)) {
                throw new Error(`Cannot invoke instructions. Missing package "${this.packageName}"`);
            }
            throw error;
        }
    }
    /**
     * Load package json file from the package root directory
     */
    loadPackageJsonFile() {
        return require(this.packagePath);
    }
    /**
     * Copies templates to the user project
     */
    copyTemplates(instructions) {
        if (!instructions.templates) {
            return;
        }
        const templatesSourceDir = instructions.templates.basePath || './build/templates';
        const templatesManager = new TemplatesManager_1.TemplatesManager(this.projectRoot, path_1.join(path_1.dirname(this.packagePath), templatesSourceDir), this.application);
        templatesManager.copy(instructions.templates);
    }
    /**
     * Set environment variables
     */
    setEnvVariables(instructions) {
        if (!instructions.env) {
            return;
        }
        const envFile = new sink.files.EnvFile(this.projectRoot);
        Object.keys(instructions.env).forEach((envKey) => envFile.set(envKey, instructions.env[envKey]));
        envFile.commit();
        logger_1.logger.update({ message: '.env' });
    }
    /**
     * Adds the types to the tsconfig.json file
     */
    setTypes(instructions) {
        if (!instructions.types) {
            return;
        }
        const fileName = 'tsconfig.json';
        const tsConfig = new sink.files.JsonFile(this.projectRoot, fileName);
        const existingTypes = tsConfig.get('compilerOptions.types') || [];
        /**
         * Push type when doesn't exists already
         */
        if (!existingTypes.find((type) => type.includes(instructions.types))) {
            existingTypes.push(instructions.types);
            tsConfig.set('compilerOptions.types', existingTypes);
            tsConfig.commit();
        }
        const suffix = this.verbose ? `{ types += ${instructions.types} }` : '';
        logger_1.logger.update({ message: fileName, suffix });
    }
    /**
     * Set commands inside the adonisrc.json file
     */
    setCommands(instructions) {
        if (!instructions.commands) {
            return;
        }
        const adonisRcFile = new sink.files.AdonisRcFile(this.projectRoot);
        instructions.commands.forEach((command) => adonisRcFile.addCommand(command));
        adonisRcFile.commit();
        const suffix = this.verbose ? `{ commands += ${instructions.commands} }` : '';
        logger_1.logger.update({ message: '.adonisrc.json', suffix });
    }
    /**
     * Sets providers or ace providers inside the `.adonisrc.json` file
     */
    setProviders(instructions) {
        let suffix = '';
        /**
         * Return early when not providers are mentioned
         */
        if (!instructions.providers && !instructions.aceProviders) {
            return;
        }
        const adonisRcFile = new sink.files.AdonisRcFile(this.projectRoot);
        if (instructions.providers) {
            instructions.providers.forEach((provider) => adonisRcFile.addProvider(provider));
            suffix += `{ providers += ${instructions.providers} } `;
        }
        if (instructions.aceProviders) {
            instructions.aceProviders.forEach((provider) => adonisRcFile.addAceProvider(provider));
            suffix += `{ aceProviders += ${instructions.aceProviders} }`;
        }
        adonisRcFile.commit();
        logger_1.logger.update({ message: '.adonisrc.json', suffix: this.verbose ? suffix : '' });
    }
    /**
     * Executes the instructions fn exposed by the package inside package.json file.
     */
    async runInstructions(instructions) {
        if (!instructions.instructions) {
            return;
        }
        /**
         * Path to the instructions file is resolved from the package root.
         */
        const instructionsPath = utils_1.resolveFrom(path_1.dirname(this.packagePath), instructions.instructions);
        /**
         * Requiring and executing instructions file
         */
        const instructionsFn = utils_1.esmRequire(instructionsPath);
        await instructionsFn(this.projectRoot, this.application, sink);
    }
    /**
     * Renders the markdown file if defined inside the package.json file.
     */
    async renderMarkdownFile(instructions) {
        if (!instructions.instructionsMd || !this.verbose) {
            return;
        }
        if (!this.markdownDisplay) {
            logger_1.logger.info('The package wants to display readable instructions for the setup');
            this.markdownDisplay = await sink.getPrompt().choice('Select where to display instructions', [
                {
                    name: 'browser',
                    message: 'In the browser',
                },
                {
                    name: 'terminal',
                    message: 'In the terminal',
                },
            ]);
        }
        /**
         * Render markdown file when `instructionsMd` property is defined in
         * package.json file
         */
        const renderer = new sink.tasks.MarkdownRenderer(path_1.join(path_1.dirname(this.packagePath), instructions.instructionsMd), this.packageName);
        if (this.markdownDisplay === 'browser') {
            renderer.renderInBrowser();
        }
        else {
            console.log('');
            renderer.renderInTerminal();
        }
    }
    /**
     * Preset markdown display for avoiding prompt
     */
    setDisplay(display) {
        this.markdownDisplay = display;
        return this;
    }
    /**
     * Execute the instructions file
     */
    async execute() {
        const pkg = this.loadPackageJsonFile();
        if (!pkg.adonisjs) {
            return true;
        }
        this.copyTemplates(pkg.adonisjs);
        this.setEnvVariables(pkg.adonisjs);
        this.setTypes(pkg.adonisjs);
        this.setCommands(pkg.adonisjs);
        this.setProviders(pkg.adonisjs);
        await this.runInstructions(pkg.adonisjs);
        await this.renderMarkdownFile(pkg.adonisjs);
        return true;
    }
}
exports.Instructions = Instructions;

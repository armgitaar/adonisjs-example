/// <reference types="node" />
import { EventEmitter } from 'events';
/**
 * Shape of class constructor
 */
declare type Constructor<T> = new (...args: any[]) => T;
/**
 * Shape of class constructor with `makePlain` property
 */
declare type PlainConstructor = {
    new (...args: any[]): any;
    makePlain: boolean;
};
/**
 * The intefered type of the `make` function
 */
export declare type MakeInferedType<T extends any> = T extends string | LookupNode ? any : (T extends PlainConstructor ? T : (T extends Constructor<infer A> ? A : T));
/**
 * Custom traces must implement this interface
 */
export interface TracerContract extends EventEmitter {
    in(namespace: string, cached: boolean): void;
    out(): void;
}
/**
 * Shape of resolved lookup node, resolved using `getResolver().resolve()`
 * method.
 */
export declare type IocResolverLookupNode = {
    namespace: string;
    type: 'binding' | 'autoload';
    method: string;
};
/**
 * The resolve is used to resolve and cache IoC container bindings that
 * are meant to stay static through out the application and reduce
 * the cost of lookup on each iteration.
 */
export interface IocResolverContract {
    resolve(namespace: string, prefixNamespace?: string): IocResolverLookupNode;
    call<T extends any>(namespace: string | IocResolverLookupNode, prefixNamespace?: string, args?: any[]): T;
}
/**
 * Ioc container interface
 */
export interface IocContract {
    tracer: TracerContract;
    autoloads: {
        [namespace: string]: string;
    };
    autoloadedAliases: string[];
    useProxies(): this;
    bind(namespace: string, callback: BindCallback): void;
    singleton(namespace: string, callback: BindCallback): void;
    alias(namespace: string, alias: string): void;
    fake(namespace: string, callback: BindFakeCallback): void;
    autoload(directoryPath: string, namespace: string): void;
    use<T extends any = any>(namespace: string | LookupNode): T;
    make<T extends any>(namespace: T, args?: any[]): MakeInferedType<T>;
    useFake<T extends any = any>(namespace: string, value?: any): T;
    hasFake(namespace: string): boolean;
    hasAlias(namespace: string): boolean;
    hasBinding(namespace: string, checkAliases?: boolean): boolean;
    getAliasNamespace(namespace: string): string | undefined;
    isAutoloadNamespace(namespace: string): boolean;
    getAutoloadBaseNamespace(namespace: string): string | undefined;
    clearAutoloadCache(namespace?: string, clearRequireCache?: boolean): void;
    restore(namespace: string): void;
    with(namespaces: string[], cb: (...args: any[]) => void): void;
    call<T extends object, K extends keyof T = any>(target: T, method: K, args: any[]): any;
    lookup(namespace: string, prefixNamespace?: string): LookupNode | null;
    getResolver(fallbackMethod?: string, rcNamespaceKey?: string, fallbackNamespace?: string): IocResolverContract;
}
/**
 * Shape of binding stored inside the IoC container
 */
export declare type Binding = {
    callback: BindCallback;
    singleton: boolean;
    cachedValue?: unknown;
};
/**
 * Shape of fakes binding stored inside the IoC container
 */
export declare type FakeBinding = {
    callback: BindFakeCallback;
    cachedValue?: unknown;
};
/**
 * Shape of lookup node pulled using `ioc.lookup` method. This node
 * can be passed to `ioc.use`, or `ioc.make` or `ioc.useEsm` to
 * skip many checks and resolve the binding right away.
 */
export declare type LookupNode = {
    namespace: string;
    type: 'binding' | 'autoload';
};
/**
 * Shape of autoloaded cache entry
 */
export declare type AutoloadCacheItem = {
    diskPath: string;
    cachedValue: any;
};
/**
 * Shape of the bind callback method
 */
export declare type BindCallback = (app: IocContract) => unknown;
/**
 * Shape of the fake callback method
 */
export declare type BindFakeCallback = (app: IocContract, value?: any) => unknown;
export {};

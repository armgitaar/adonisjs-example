"use strict";
/*
 * @adonisjs/assembler
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildWatcher = void 0;
const chokidar_1 = __importDefault(require("chokidar"));
const get_port_1 = __importDefault(require("get-port"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const fancy_logs_1 = require("@poppinss/fancy-logs");
const RcFile_1 = require("../RcFile");
const Manifest_1 = require("../Manifest");
const HttpServer_1 = require("../HttpServer");
const paths_1 = require("../../config/paths");
const EnvParser_1 = require("../EnvParser");
/**
 * Exposes the API to watch the output build folder and restart
 * HTTP server on changes.
 */
class BuildWatcher {
    constructor(buildRoot, nodeArgs, logger = new fancy_logs_1.Logger()) {
        this.buildRoot = buildRoot;
        this.nodeArgs = nodeArgs;
        this.logger = logger;
        this.manifest = new Manifest_1.Manifest(this.buildRoot, this.logger);
    }
    /**
     * Returns true when filePath is .js or .json. We need this to
     * restart the HTTP server
     */
    isScriptFile(filePath) {
        return ['.js', '.json'].includes(path_1.extname(filePath));
    }
    /**
     * Watch for compiled output changes
     */
    async watch(buildDir, poll = false) {
        const absPath = path_1.join(this.buildRoot, buildDir);
        const hasBuildDir = await fs_extra_1.pathExists(absPath);
        if (!hasBuildDir) {
            this.logger.error(`"${buildDir}" doesn't exists. Make sure to compile the source code first.`);
            return;
        }
        /**
         * Parser the .env file
         */
        const envParser = new EnvParser_1.EnvParser();
        await envParser.parse(absPath);
        /**
         * Pull defined env values inside an object (only if defined)
         */
        const envOptions = envParser.asEnvObject(['PORT', 'TZ']);
        /**
         * Obtains a random port by giving preference to the one defined inside
         * the `.env` file. This eases the process of running the application
         * without manually changing ports inside the `.env` file when
         * original port is in use.
         */
        if (envOptions.PORT) {
            envOptions.PORT = String(await get_port_1.default({
                port: [Number(envOptions.PORT)],
                host: envParser.get('HOST'),
            }));
        }
        const rcFile = new RcFile_1.RcFile(absPath);
        const httpServer = new HttpServer_1.HttpServer(paths_1.SERVER_ENTRY_FILE, absPath, this.nodeArgs, this.logger, envOptions);
        /**
         * Initate watcher. Instead of ignoring files upfront, we use the
         * events handler to filter out files.
         */
        const watcher = chokidar_1.default.watch(['.'], {
            ignoreInitial: true,
            usePolling: poll,
            cwd: absPath,
            ignored: [
                'node_modules/**',
            ],
        });
        /**
         * Notify that server has died
         */
        httpServer.on('exit', ({ code }) => {
            this.logger.stop('Underlying HTTP server died with "%s code"', code);
        });
        /**
         * Handle new file additions
         */
        watcher.on('add', (filePath) => {
            const metaData = rcFile.getMetaData(filePath);
            const isScriptFile = this.isScriptFile(filePath);
            if (isScriptFile || metaData.reload) {
                this.logger.create(filePath);
                httpServer.restart();
            }
            if (isScriptFile && rcFile.isCommandsPath(filePath)) {
                this.manifest.generate();
            }
        });
        /**
         * Handle file updates
         */
        watcher.on('change', (filePath) => {
            const metaData = rcFile.getMetaData(filePath);
            const isScriptFile = this.isScriptFile(filePath);
            if (isScriptFile || metaData.reload) {
                this.logger.update(filePath);
                httpServer.restart();
            }
            if (isScriptFile && rcFile.isCommandsPath(filePath)) {
                this.manifest.generate();
            }
        });
        /**
         * Handle file removals
         */
        watcher.on('unlink', (filePath) => {
            const metaData = rcFile.getMetaData(filePath);
            const isScriptFile = this.isScriptFile(filePath);
            if (metaData.rcFile) {
                this.logger.stop('cannot continue after deletion of .adonisrc.json file');
                watcher.close();
                return;
            }
            if (isScriptFile || metaData.reload) {
                this.logger.delete(filePath);
                httpServer.restart();
            }
            if (isScriptFile && rcFile.isCommandsPath(filePath)) {
                this.manifest.generate();
            }
        });
        /**
         * Start the http server when watcher is ready
         */
        watcher.on('ready', () => {
            this.logger.watch({ message: 'watching for file changes', suffix: buildDir });
            httpServer.start();
        });
    }
}
exports.BuildWatcher = BuildWatcher;

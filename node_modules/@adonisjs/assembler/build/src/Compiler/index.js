"use strict";
/*
* @adonisjs/assembler
*
* (c) Harminder Virk <virk@adonisjs.com>
*
* For the full copyright and license information, please view the LICENSE
* file that was distributed with this source code.
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
const mem_1 = __importDefault(require("mem"));
const slash_1 = __importDefault(require("slash"));
const cpy_1 = __importDefault(require("cpy"));
const get_port_1 = __importDefault(require("get-port"));
const debounce_1 = __importDefault(require("debounce"));
const path_1 = require("path");
const colors_1 = require("@poppinss/colors");
const fancy_logs_1 = require("@poppinss/fancy-logs");
const utils_1 = require("@poppinss/utils");
const fs_extra_1 = require("fs-extra");
const chokidar_ts_1 = require("@poppinss/chokidar-ts");
const ioc_transformer_1 = require("@adonisjs/ioc-transformer");
const RcFile_1 = require("../RcFile");
const Manifest_1 = require("../Manifest");
const HttpServer_1 = require("../HttpServer");
const paths_1 = require("../../config/paths");
const EnvParser_1 = require("../EnvParser");
/**
 * Exposes the API to build the AdonisJs project for development or
 * production. The production build has it's own set of node_modules
 */
class Compiler {
    constructor(appRoot, serveApp, nodeArgs = [], logger = new fancy_logs_1.Logger()) {
        this.appRoot = appRoot;
        this.serveApp = serveApp;
        this.nodeArgs = nodeArgs;
        this.logger = logger;
        /**
         * Reference to typescript compiler
         */
        this.tsCompiler = new chokidar_ts_1.TypescriptCompiler(this.appRoot, paths_1.TSCONFIG_FILE_NAME, require(utils_1.resolveFrom(this.appRoot, 'typescript/lib/typescript')));
        /**
         * Reference to rc File
         */
        this.rcFile = new RcFile_1.RcFile(this.appRoot);
        /**
         * Manifest instance to generate ace manifest file
         */
        this.manifest = new Manifest_1.Manifest(this.appRoot, this.logger);
        /**
         * Same as [[this.writeRcFile]] but waits for 2secs
         */
        this.touchRcFile = debounce_1.default(this.writeRcFile.bind(this), 2000);
        /**
         * Returns relative unix path from the project root. Used for
         * display only
         */
        this.getRelativeUnixPath = mem_1.default((absPath) => slash_1.default(path_1.relative(this.appRoot, absPath)));
        this.colors = new colors_1.Colors();
        this.tsCompiler.use(() => {
            return ioc_transformer_1.iocTransformer(this.tsCompiler.ts, this.rcFile.application.rcFile);
        }, 'after');
    }
    /**
     * write .adonisrc.json file to the build directory
     */
    async writeRcFile(outDir) {
        await fs_extra_1.outputJSON(path_1.join(outDir, paths_1.RCFILE_NAME), Object.assign({}, this.rcFile.getDiskContents(), {
            typescript: false,
            lastCompiledAt: new Date().toISOString(),
        }), { spaces: 2 });
    }
    /**
     * Create the http server
     */
    async createHttpServer(outDir) {
        if (this.httpServer) {
            return;
        }
        const envParser = new EnvParser_1.EnvParser();
        await envParser.parse(outDir);
        const envOptions = envParser.asEnvObject(['PORT', 'TZ']);
        /**
         * Obtains a random port by giving preference to the one defined inside
         * the `.env` file. This eases the process of running the application
         * without manually changing ports inside the `.env` file when
         * original port is in use.
         */
        if (envOptions.PORT) {
            envOptions.PORT = String(await get_port_1.default({
                port: [Number(envOptions.PORT)],
                host: envParser.get('HOST'),
            }));
        }
        const Server = this.serveApp ? HttpServer_1.HttpServer : HttpServer_1.DummyHttpServer;
        this.httpServer = new Server(paths_1.SERVER_ENTRY_FILE, outDir, this.nodeArgs, this.logger, envOptions);
    }
    /**
     * Render ts diagnostics
     */
    renderDiagnostics(diagnostics, host) {
        console.log(this.tsCompiler.ts.formatDiagnosticsWithColorAndContext(diagnostics, host));
    }
    /**
     * Parses the tsconfig file
     */
    parseConfig() {
        const { error, config } = this.tsCompiler.configParser().parse();
        if (error) {
            this.logger.error(`unable to compile ${paths_1.TSCONFIG_FILE_NAME}`);
            this.renderDiagnostics([error], this.tsCompiler.ts.createCompilerHost({}));
            return;
        }
        if (config && config.errors.length) {
            this.logger.error(`unable to compile ${paths_1.TSCONFIG_FILE_NAME}`);
            this.renderDiagnostics(config.errors, this.tsCompiler.ts.createCompilerHost(config.options));
            return;
        }
        config.options.rootDir = config.options.rootDir || this.appRoot;
        config.options.outDir = config.options.outDir || path_1.join(this.appRoot, paths_1.DEFAULT_BUILD_DIR);
        return config;
    }
    /**
     * Cleans up the build directory
     */
    async cleanupBuildDirectory(outDir) {
        this.logger.info({ message: 'cleaning up build directory', suffix: this.getRelativeUnixPath(outDir) });
        await fs_extra_1.remove(outDir);
    }
    /**
     * Copies .adonisrc.json file to the destination
     */
    async copyAdonisRcFile(outDir) {
        this.logger.info({ message: `copy ${paths_1.RCFILE_NAME}`, suffix: this.getRelativeUnixPath(outDir) });
        await this.writeRcFile(outDir);
    }
    /**
     * Copy all meta files to the build directory
     */
    async copyMetaFiles(outDir, extraFiles) {
        const metaFiles = this.rcFile.getMetaFilesGlob().concat(extraFiles || []);
        this.logger.info({ message: `copy ${metaFiles.join(',')}`, suffix: this.getRelativeUnixPath(outDir) });
        await this.copyFiles(metaFiles, outDir);
    }
    /**
     * Copy files to destination directory
     */
    async copyFiles(files, outDir) {
        try {
            await cpy_1.default(files, outDir, { cwd: this.appRoot, parents: true });
        }
        catch (error) {
            if (!error.message.includes('the file doesn\'t exist')) {
                throw error;
            }
        }
    }
    /**
     * Build typescript source files
     */
    buildTypescriptSource(config) {
        this.logger.pending('compiling typescript source files');
        const builder = this.tsCompiler.builder(config);
        const { skipped, diagnostics } = builder.build();
        if (skipped) {
            this.logger.info('TS emit skipped');
        }
        if (diagnostics.length) {
            this.logger.error('typescript compiler errors');
            this.renderDiagnostics(diagnostics, builder.host);
        }
        else {
            this.logger.success('built successfully');
        }
    }
    /**
     * Compile project. See [[Compiler.compileForProduction]] for
     * production build
     */
    async compile() {
        const config = this.parseConfig();
        if (!config) {
            return false;
        }
        await this.cleanupBuildDirectory(config.options.outDir);
        await this.copyMetaFiles(config.options.outDir);
        this.buildTypescriptSource(config);
        await this.copyAdonisRcFile(config.options.outDir);
        await this.manifest.generate();
        /**
         * Start HTTP server
         */
        if (this.serveApp) {
            await this.createHttpServer(config.options.outDir);
            this.httpServer.start();
        }
        return true;
    }
    /**
     * Compile project. See [[Compiler.compile]] for development build
     */
    async compileForProduction(client) {
        const config = this.parseConfig();
        if (!config) {
            return false;
        }
        const pkgFiles = client === 'npm'
            ? ['package.json', 'package-lock.json']
            : ['package.json', 'yarn.lock'];
        await this.cleanupBuildDirectory(config.options.outDir);
        await this.copyMetaFiles(config.options.outDir, pkgFiles);
        this.buildTypescriptSource(config);
        await this.copyAdonisRcFile(config.options.outDir);
        await this.manifest.generate();
        const installCommand = client === 'npm'
            ? 'npm ci --production'
            : 'yarn install --production';
        console.log('   Run the following commands to start the server in production');
        const relativeBuildPath = this.getRelativeUnixPath(config.options.outDir);
        console.log(`   ${this.colors.gray('$')} ${this.colors.cyan(`cd ${relativeBuildPath}`)}`);
        console.log(`   ${this.colors.gray('$')} ${this.colors.cyan(installCommand)}`);
        console.log(`   ${this.colors.gray('$')} ${this.colors.cyan('node server.js')}`);
        return true;
    }
}
exports.Compiler = Compiler;

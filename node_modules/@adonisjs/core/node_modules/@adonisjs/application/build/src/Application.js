"use strict";
/*
 * @adonisjs/application
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const path_1 = require("path");
const semver_1 = require("semver");
const rcParser_1 = require("./rcParser");
/**
 * Aliases for different environments
 */
const DEV_ENVS = ['dev', 'develop', 'development'];
const STAGING_ENVS = ['stage', 'staging'];
const PROD_ENVS = ['prod', 'production'];
const TEST_ENVS = ['test', 'testing'];
/**
 * The main application instance to know about the environment, filesystem
 * in which your AdonisJs app is running
 */
class Application {
    constructor(appRoot, container, rcContents, pkgFile) {
        this.appRoot = appRoot;
        this.container = container;
        /**
         * A boolean to know if application has bootstrapped successfully
         */
        this.isReady = false;
        /**
         * Current working directory for the CLI and not the build directory
         * The `ADONIS_CLI_CWD` is set by the cli
         */
        this.cliCwd = process.env.ADONIS_ACE_CWD;
        /**
         * A boolean to know if application has received a shutdown signal
         * like `SIGINT` or `SIGTERM`.
         */
        this.isShuttingDown = false;
        /**
         * The environment in which application is running
         */
        this.environment = 'unknown';
        /**
         * A array of files to be preloaded
         */
        this.preloads = [];
        /**
         * A map of pre-configured directories
         */
        this.directoriesMap = new Map();
        /**
         * A map of directories aliases
         */
        this.aliasesMap = new Map();
        /**
         * A map of namespaces that different parts of apps
         * can use
         */
        this.namespacesMap = new Map();
        this.rcFile = rcParser_1.parse(rcContents);
        this.typescript = this.rcFile.typescript;
        /**
         * Fetching following info from the package file
         */
        this.appName = pkgFile.name || 'adonis-app';
        this.version = this.parseVersion(pkgFile.version || '0.0.0');
        this.adonisVersion = pkgFile.adonisVersion ? this.parseVersion(pkgFile.adonisVersion) : null;
        /**
         * Fetching following info from the `.adonisrc.json` file.
         */
        this.exceptionHandlerNamespace = this.rcFile.exceptionHandlerNamespace;
        this.preloads = this.rcFile.preloads;
        this.directoriesMap = new Map(Object.entries(this.rcFile.directories));
        this.aliasesMap = new Map(Object.entries(this.rcFile.aliases));
        this.namespacesMap = new Map(Object.entries(this.rcFile.namespaces));
        this.setEnvVars();
    }
    /**
     * Parses version string to an object.
     */
    parseVersion(version) {
        const parsed = semver_1.parse(version);
        if (!parsed) {
            return null;
        }
        return {
            major: parsed.major,
            minor: parsed.minor,
            patch: parsed.patch,
            prerelease: parsed.prerelease.map((release) => release),
            version: parsed.version,
            toString() {
                return this.version;
            },
        };
    }
    /**
     * Sets env variables based upon the provided application info.
     */
    setEnvVars() {
        process.env.APP_NAME = this.appName;
        if (this.version) {
            process.env.APP_VERSION = this.version.version;
        }
    }
    /**
     * Normalizes node env
     */
    normalizeNodeEnv(env) {
        env = env.toLowerCase();
        if (DEV_ENVS.includes(env)) {
            return 'development';
        }
        if (STAGING_ENVS.includes(env)) {
            return 'staging';
        }
        if (PROD_ENVS.includes(env)) {
            return 'production';
        }
        if (TEST_ENVS.includes(env)) {
            return 'testing';
        }
        return env;
    }
    /**
     * The environment in which application is running
     */
    get nodeEnvironment() {
        /**
         * If nodeEnv is undefined, then attempt to read the value from `NODE_ENV`
         * and cache it (if defined)
         */
        if (this.cachedNodeEnv === undefined && process.env.NODE_ENV) {
            this.cachedNodeEnv = this.normalizeNodeEnv(process.env.NODE_ENV);
        }
        /**
         * If still undefined
         */
        if (this.cachedNodeEnv === undefined) {
            return 'unknown';
        }
        return this.cachedNodeEnv;
    }
    /**
     * Return true when `this.nodeEnvironment === 'production'`
     */
    get inProduction() {
        return this.nodeEnvironment === 'production';
    }
    /**
     * Opposite of [[this.isProduction]]
     */
    get inDev() {
        return !this.inProduction;
    }
    /**
     * Returns path for a given namespace by replacing the base namespace
     * with the defined directories map inside the rc file.
     *
     * The method returns a relative path from the application root. You can
     * use join it with the [[this.appRoot]] to make the absolute path
     */
    resolveNamespaceDirectory(namespaceFor) {
        /**
         * Return null when rcfile doesn't have a special
         * entry for namespaces
         */
        if (!this.rcFile.namespaces[namespaceFor]) {
            return null;
        }
        let output = null;
        Object.keys(this.rcFile.aliases).forEach((baseNamespace) => {
            const autoloadPath = this.rcFile.aliases[baseNamespace];
            if (this.rcFile.namespaces[namespaceFor].startsWith(`${baseNamespace}/`) ||
                this.rcFile.namespaces[namespaceFor] === baseNamespace) {
                output = this.rcFile.namespaces[namespaceFor].replace(baseNamespace, autoloadPath);
            }
        });
        return output;
    }
    /**
     * Make path to a file or directory relative from
     * the application path
     */
    makePath(...paths) {
        return path_1.join(this.appRoot, ...paths);
    }
    /**
     * Makes the path to a directory from `cliCwd` vs the `appRoot`. This is
     * helpful when we want path inside the project root and not the
     * build directory
     */
    makePathFromCwd(...paths) {
        return path_1.join(this.cliCwd || this.appRoot, ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the config directory
     */
    configPath(...paths) {
        return this.makePath(this.directoriesMap.get('config'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the public path
     */
    publicPath(...paths) {
        return this.makePath(this.directoriesMap.get('public'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the providers path
     */
    providersPath(...paths) {
        return this.makePath(this.directoriesMap.get('providers'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the database path
     */
    databasePath(...paths) {
        return this.makePath(this.directoriesMap.get('database'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the migrations path
     */
    migrationsPath(...paths) {
        return this.makePath(this.directoriesMap.get('migrations'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the seeds path
     */
    seedsPath(...paths) {
        return this.makePath(this.directoriesMap.get('seeds'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the resources path
     */
    resourcesPath(...paths) {
        return this.makePath(this.directoriesMap.get('resources'), ...paths);
    }
    /**
     * Make path to a file or directory relative from
     * the views path
     */
    viewsPath(...paths) {
        return this.makePath(this.directoriesMap.get('views'), ...paths);
    }
    /**
     * Makes path to the start directory
     */
    startPath(...paths) {
        return this.makePath(this.directoriesMap.get('start'), ...paths);
    }
    /**
     * Makes path to the tests directory
     */
    testsPath(...paths) {
        return this.makePath(this.directoriesMap.get('tests'), ...paths);
    }
    /**
     * Makes path to the tmp directory. Since the tmp path is used for
     * writing at the runtime, we use `cwd` path to the write to the
     * source and not the build directory.
     */
    tmpPath(...paths) {
        return this.makePathFromCwd(this.directoriesMap.get('tmp'), ...paths);
    }
    /**
     * Serialized output
     */
    toJSON() {
        return {
            isReady: this.isReady,
            isShuttingDown: this.isShuttingDown,
            environment: this.environment,
            nodeEnvironment: this.nodeEnvironment,
            appName: this.appName,
            version: this.version ? this.version.toString() : null,
            adonisVersion: this.adonisVersion ? this.adonisVersion.toString() : null,
        };
    }
}
exports.Application = Application;

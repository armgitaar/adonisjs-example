/// <reference path="../../adonis-typings/hash.d.ts" />
/// <reference path="../../test-helpers/contracts.d.ts" />
import { Manager } from '@poppinss/manager';
import { IocContract } from '@adonisjs/fold';
import { HashConfig, HashersList, HashContract, HashDriverContract, FakeContract } from '@ioc:Adonis/Core/Hash';
/**
 * The Hash module exposes the API to hash values using an underlying
 * Hash driver.
 */
export declare class Hash<Config extends HashConfig> extends Manager<IocContract, HashDriverContract, HashDriverContract, {
    [P in keyof HashersList]: HashersList[P]['implementation'];
}> implements HashContract {
    config: Config;
    /**
     * Reference to fake driver. Created when `Hash.fake` is called
     */
    private fakeDriver;
    protected singleton: boolean;
    /**
     * A boolean to know, if hash module is running in fake
     * mode or not
     */
    get isFaked(): boolean;
    constructor(container: any, config: Config);
    /**
     * Validate config
     */
    private validateConfig;
    /**
     * Pulling the default driver name from the user config.
     */
    protected getDefaultMappingName(): "bcrypt" | "argon";
    /**
     * Returns the config for a mapping
     */
    protected getMappingConfig(name: keyof HashersList): import("@ioc:Adonis/Core/Hash").BcryptConfig | import("@ioc:Adonis/Core/Hash").ArgonConfig;
    /**
     * Returns the driver name for a mapping
     */
    protected getMappingDriver(name: keyof HashersList): string | undefined;
    /**
     * Creating bcrypt driver. The manager will call this method anytime
     * someone will ask for the `bcrypt` driver.
     */
    protected createBcrypt(_: string, config: any): any;
    /**
     * Creating argon driver. The manager will call this method anytime
     * someone will ask for the `argon` driver.
     */
    protected createArgon2(_: string, config: any): any;
    /**
     * Creating fake driver. The manager will call this method anytime
     * someone will ask for the `fake` driver.
     */
    protected createFake(): any;
    /**
     * Initiate faking hash calls. All methods invoked on the main hash
     * module and the underlying drivers will be faked using the
     * fake driver.
     *
     * To restore the fake. Run the `Hash.restore` method.
     */
    fake(): void;
    /**
     * Restore fake
     */
    restore(): void;
    /**
     * Alias for [[this.make]]
     */
    hash(value: string): never | any;
    /**
     * Hash value using the default driver
     */
    make(value: string): Promise<string>;
    /**
     * Verify value using the default driver
     */
    verify(hashedValue: string, plainValue: string): Promise<boolean>;
    /**
     * Find if value needs to be re-hashed as per the default driver.
     */
    needsReHash(hashedValue: string): boolean;
    /**
     * Pull pre-configured driver instance
     */
    use<K extends keyof HashersList>(name?: K): import("@ioc:Adonis/Core/Hash").BcryptContract | import("@ioc:Adonis/Core/Hash").ArgonContract | FakeContract | {
        argon: import("@ioc:Adonis/Core/Hash").ArgonContract;
        bcrypt: import("@ioc:Adonis/Core/Hash").BcryptContract;
    }[K];
}
